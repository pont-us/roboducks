% Remember to use the lgrind style

\Head{}
\File{code/neurotic/Net.java}{2001}{5}{6}{19:11}{10448}
\L{\LB{\K{package}_\V{neurotic};}}
\L{\LB{}}
\L{\LB{\K{import}_\V{java}.\V{io}.*;}}
\L{\LB{\K{import}_\V{java}.\V{util}.*;}}
\L{\LB{}}
\L{\LB{\C{}/*_Simple_recurrent_neural_net_package,_second_attempt._*/\CE{}}}
\L{\LB{}}
\L{\LB{\K{class}_\V{Debug}_\{}}
\L{\LB{}\Tab{4}{\K{public}_\K{static}_\K{boolean}_\V{on}_=_\K{false};}}
\L{\LB{}\Tab{4}{\K{public}_\K{static}_\K{boolean}_\V{lots}_=_\K{false};}}
\L{\LB{\}}}
\L{\LB{}}
\L{\LB{\K{public}_\K{class}_\V{Net}_\{}}
\L{\LB{}\Tab{2}{\V{InputNode}[\,]_\V{ilyr};}\Tab{24}{\C{}//_input_layer\CE{}}}
\L{\LB{}\Tab{2}{\V{ContextNode}[\,]_\V{clyr};}\Tab{24}{\C{}//_context_layer\CE{}}}
\L{\LB{}\Tab{2}{\V{Neuron}[\,]_\V{hlyr};}\Tab{24}{\C{}//_hidden_layer\CE{}}}
\L{\LB{}\Tab{2}{\V{Neuron}[\,]_\V{olyr};}\Tab{24}{\C{}//_output_layer\CE{}}}
\L{\LB{}\Tab{2}{\K{public}_\K{float}_\V{rate};}\Tab{24}{\C{}//_learning_rate\CE{}}}
\L{\LB{}\Tab{2}{\K{public}_\K{float}_\V{momentum};}}
\L{\LB{}\Tab{2}{\K{float}_\V{sumSqError};}\Tab{24}{\C{}//_sum_of_squared_errors\CE{}}}
\L{\LB{}\Tab{2}{\V{Random}_\V{rnd};}\Tab{24}{\C{}//_our_random_generator_(for_weights)\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}/*_Network_architecture_is_normal_feedforward,_or_SRN}}
\L{\LB{}\Tab{7}{like_Elman_{'}90,_depending_on_{`}recurrent{'}_flag_*/\CE{}}}
\index{Net}\Proc{Net}\L{\LB{}\Tab{2}{\K{public}_\V{Net}(\K{int}_\V{inputs},_\K{int}_\V{hiddens},_\K{int}_\V{outputs},_\K{boolean}_\V{recurrent})_\{}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\V{rnd}_=_\K{new}_\V{Random}();}}
\L{\LB{}\Tab{4}{\K{int}_\V{contexts}_=_\V{recurrent}_?_\V{hiddens}_\V{:}_\N{0};}\Tab{48}{\C{}//_\#_context_nodes\CE{}}}
\L{\LB{}\Tab{4}{\V{ilyr}_=_\K{new}_\V{InputNode}[\V{inputs}+\N{1}];_\C{}//_extra_one_for_threshold_bias\CE{}}}
\L{\LB{}\Tab{4}{\V{clyr}_=_\K{new}_\V{ContextNode}[\V{contexts}];}}
\L{\LB{}\Tab{4}{\V{hlyr}_=_\K{new}_\V{Neuron}[\V{hiddens}];}}
\L{\LB{}\Tab{4}{\V{olyr}_=_\K{new}_\V{Neuron}[\V{outputs}];}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\V{rate}_=_\N{0.1f};}\Tab{41}{\C{}//_learning_rate\CE{}}}
\L{\LB{}\Tab{4}{\V{momentum}_=_\N{0.9f};}}
\L{\LB{}\Tab{4}{\K{float}_\V{w\_centre}_=_\N{0f},_\V{w\_range}_=_\N{0.5f};_\C{}//_initial_weights\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}//_1._create_the_input_layer\CE{}}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{inputs};_\V{i}++)}}
\L{\LB{}\Tab{6}{\V{ilyr}[\V{i}]_=_\K{new}_\V{InputNode}(\N{0},_\S{}\3I\3\SE{}+\V{i});}}
\L{\LB{}\Tab{4}{\V{ilyr}[\V{inputs}]_=_\K{new}_\V{InputNode}(\N{1},_\S{}\3Bi\3\SE{});_\C{}//_bias\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}//_2._create_the_context_layer_(will_add_inputs_later)\CE{}}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{contexts};_\V{i}++)}}
\L{\LB{}\Tab{6}{\V{clyr}[\V{i}]_=_\K{new}_\V{ContextNode}(\K{this},_\N{0.5f},_\S{}\3C\3\SE{}+\V{i});}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}//_3._create_hidden_layer_\&_links_from_input/context\CE{}}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{hiddens};_\V{i}++)_\{}}
\L{\LB{}\Tab{6}{\V{Link}[\,]_\V{inLinks}_=_\K{new}_\V{Link}[\V{inputs}+\V{contexts}+\N{1}];}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{inputs};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{inLinks}[\V{j}]_=_\K{new}_\V{Link}(\V{ilyr}[\V{j}],_\K{true},_\V{w\_centre},_\V{w\_range},_\V{rnd});}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{contexts};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{inLinks}[\V{inputs}+\V{j}]_=_\K{new}_\V{Link}(\V{clyr}[\V{j}],_\K{true},_\V{w\_centre},_\V{w\_range},_\V{rnd});}}
\L{\LB{}\Tab{6}{\V{inLinks}[\V{inputs}+\V{contexts}]_=}}
\L{\LB{}\Tab{8}{\K{new}_\V{Link}(\V{ilyr}[\V{inputs}],_\K{true},_\V{w\_centre},_\V{w\_range},_\V{rnd});_\C{}//_bias\CE{}}}
\L{\LB{}\Tab{6}{\V{hlyr}[\V{i}]_=_\K{new}_\V{Neuron}(\V{inLinks},_\K{this},_\N{2},_\N{0.5f},_\S{}\3H\3\SE{}+\V{i});}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}//_4._add_backlinks_from_hidden_to_context\CE{}}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{contexts};_\V{i}++)}}
\L{\LB{}\Tab{6}{\V{clyr}[\V{i}].\V{setInput}(_\K{new}_\V{Link}(\V{hlyr}[\V{i}],_\K{false},_\N{5f},_\N{0f})_);}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}//_5._create_output_layer\CE{}}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{outputs};_\V{i}++)_\{}}
\L{\LB{}\Tab{6}{\V{Link}[\,]_\V{inLinks}_=_\K{new}_\V{Link}[\V{hiddens}+\N{1}];}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{hiddens};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{inLinks}[\V{j}]_=_\K{new}_\V{Link}(\V{hlyr}[\V{j}],_\K{true},_\V{w\_centre},_\V{w\_range},_\V{rnd});}}
\L{\LB{}\Tab{6}{\V{inLinks}[\V{hiddens}]_=}}
\L{\LB{}\Tab{8}{\K{new}_\V{Link}(\V{ilyr}[\V{inputs}],_\K{true},_\V{w\_centre},_\V{w\_range},_\V{rnd});_\C{}//_bias\CE{}}}
\L{\LB{}\Tab{6}{\V{olyr}[\V{i}]_=_\K{new}_\V{Neuron}(\V{inLinks},_\K{this},_\N{3},_\N{0.5f},_\S{}\3O\3\SE{}+\V{i});}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_Randomize_weights_of_all_links\CE{}}}
\index{randomizeWeights}\Proc{randomizeWeights}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{randomizeWeights}(\K{float}_\V{mean},_\K{float}_\V{range})_\{}}
\L{\LB{}\Tab{4}{\V{LinkEnum}_\V{e}_=_\K{new}_\V{LinkEnum}();}}
\L{\LB{}\Tab{4}{\K{while}_(\V{e}.\V{hasMoreElements}())}}
\L{\LB{}\Tab{6}{((\V{Link})_\V{e}.\V{nextElement}()).\V{randomizeWeight}(\V{mean},_\V{range},_\V{rnd});}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_functions_for_accessing_input/output_values\CE{}}}
\index{setIn}\Proc{setIn}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{setIn}(\K{int}_\V{node},_\K{float}_\V{value})_\{_\V{ilyr}[\V{node}].\V{set}(\V{value});_\}}}
\index{getIn}\Proc{getIn}\L{\LB{}\Tab{2}{\K{public}_\K{float}_\V{getIn}(\K{int}_\V{node})_\{_\K{return}_\V{ilyr}[\V{node}].\V{act}();_\}}}
\index{getOut}\Proc{getOut}\L{\LB{}\Tab{2}{\K{public}_\K{float}_\V{getOut}(\K{int}_\V{node})_\{_\K{return}_\V{olyr}[\V{node}].\V{act}();_\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_A_class_to_represent_the_activation_function_--_really}}
\L{\LB{}\Tab{5}{just_a_wrapper_around_two_float-\!\>float_methods.}}
\L{\LB{}\Tab{5}{(XXX_should_this_be_an_interface?_)_*/\CE{}}}
\L{\LB{}\Tab{2}{\K{public}_\K{abstract}_\K{class}_\V{Activation}_\{}}
\L{\LB{}\Tab{4}{\K{abstract}_\K{float}_\V{f}(\K{float}_\V{x});_\C{}//_the_activation_function\CE{}}}
\L{\LB{}\Tab{4}{\K{abstract}_\K{float}_\V{dfdx}(\K{float}_\V{x});_\C{}//_its_first_derivative\CE{}}}
\L{\LB{}\Tab{4}{\C{}//_XXX_change_the_name_of_dfdx_to_something_that{'}s_not_a_lie\CE{}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_Our_standard_(logistic)_activation_function_*/\CE{}}}
\L{\LB{}\Tab{2}{\K{private}_\K{class}_\V{Sigmoid}_\K{extends}_\V{Activation}_\{}}
\index{f}\Proc{f}\L{\LB{}\Tab{4}{\K{float}_\V{f}(\K{float}_\V{x})_\{}}
\L{\LB{}\Tab{6}{\K{float}_\V{fx};}}
\L{\LB{}\Tab{6}{\V{fx}_=_(\K{float})_(\N{1}/(\N{1}_+_\V{java}.\V{lang}.\V{Math}.\V{exp}(\-\V{x})));}}
\L{\LB{}\Tab{6}{\K{if}_(\V{Float}.\V{isNaN}(\V{fx}))_\K{throw}_\K{new}_\V{Error}(\S{}\3Aaagh!_NaN!_\3\SE{}+\V{x}+\S{}\3\2n\3\SE{});}}
\L{\LB{}\Tab{6}{\K{return}_\V{fx};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{\C{}/*_NB:_returns_slope_at_given_f(x)_(y_value)._So_it{'}s_not_really}}
\L{\LB{}\Tab{7}{df/dx._So_sue_me._*/\CE{}}}
\index{dfdx}\Proc{dfdx}\L{\LB{}\Tab{4}{\K{float}_\V{dfdx}(\K{float}_\V{x})}}
\L{\LB{}\Tab{4}{\{_\K{return}_\V{x}*(\N{1}\-\V{x});_\}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\V{Activation}_\V{act}_=_\K{new}_\V{Sigmoid}();}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_Forward-propagate_the_current_input_values\CE{}}}
\index{think}\Proc{think}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{think}()_\{}}
\L{\LB{}\Tab{4}{\C{}//_order_of_activation_will_be:_hidden,_context,_output\CE{}}}
\L{\LB{}\Tab{4}{\C{}//_(so_*initial*_activations_only_matter_for_context_nodes)\CE{}}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{hlyr}.\V{length};_\V{i}++)_\V{hlyr}[\V{i}].\V{recalc}();}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{clyr}.\V{length};_\V{i}++)_\V{clyr}[\V{i}].\V{recalc}();}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{olyr}.\V{length};_\V{i}++)_\V{olyr}[\V{i}].\V{recalc}();}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_Run_a_backprop_against_given_(correct)_output_values.}}
\L{\LB{}\Tab{5}{Again,_it{'}s_assumed_the_inputs_have_already_been_set._*/\CE{}}}
\index{train}\Proc{train}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{train}(\K{float}[\,]_\V{desired})_\{}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\V{think}();}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}//_compute_sumSqError\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\V{sumSqError}_=_\N{0};}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{olyr}.\V{length};_\V{i}++)_\{}}
\L{\LB{}\Tab{6}{\K{float}_\V{e}_=_(\V{desired}[\V{i}]_\-_\V{olyr}[\V{i}].\V{act}());}}
\L{\LB{}\Tab{6}{\V{sumSqError}_+=_\V{e}*\V{e};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\C{}//_calculate_deltas_(deltata?)\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{olyr}.\V{length};_\V{i}++)_\{}}
\L{\LB{}\Tab{6}{\V{olyr}[\V{i}].\V{delta}_=_(\V{desired}[\V{i}]_\-_\V{olyr}[\V{i}].\V{act}())_*}}
\L{\LB{}\Tab{8}{\V{act}.\V{dfdx}(\V{olyr}[\V{i}].\V{act}());}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{hlyr}.\V{length};_\V{i}++)_\{}}
\L{\LB{}\Tab{6}{\V{hlyr}[\V{i}].\V{delta}_=_\N{0};}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{hlyr}[\V{i}].\V{outputs}.\V{length};_\V{j}++)}}
\L{\LB{}\Tab{8}{\K{if}_(\V{hlyr}[\V{i}].\V{outputs}[\V{j}].\V{trainable})}}
\L{\LB{}\Tab{10}{\V{hlyr}[\V{i}].\V{delta}_+=}}
\L{\LB{}\Tab{12}{\V{hlyr}[\V{i}].\V{outputs}[\V{j}].\V{weight}_*}}
\L{\LB{}\Tab{12}{\V{hlyr}[\V{i}].\V{outputs}[\V{j}].\V{output}.\V{delta}();}}
\L{\LB{}\Tab{6}{\V{hlyr}[\V{i}].\V{delta}_*=_\V{act}.\V{dfdx}(\V{hlyr}[\V{i}].\V{act}());}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{4}{\V{calcInputWeights}(\V{olyr});}}
\L{\LB{}\Tab{4}{\V{calcInputWeights}(\V{hlyr});}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_Apply_(possibly_accumulated)_weight_changes;_resetDeltas()}}
\L{\LB{}\Tab{5}{should_be_called_after_this_method._*/\CE{}}}
\index{changeWeights}\Proc{changeWeights}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{changeWeights}()_\{}}
\L{\LB{}\Tab{4}{\V{LinkEnum}_\V{e}_=_\K{new}_\V{LinkEnum}(\K{true});}}
\L{\LB{}\Tab{8}{\C{}//_shouldn{'}t_make_any_difference_which_way_we_go_actually\CE{}}}
\L{\LB{}\Tab{4}{\K{while}_(\V{e}.\V{hasMoreElements}())_\{}}
\L{\LB{}\Tab{6}{\V{Link}_\V{l}_=_(\V{Link})_\V{e}.\V{nextElement}();}}
\L{\LB{}\Tab{6}{\V{l}.\V{dw}_=_\V{l}.\V{wacc}_+_\V{l}.\V{dw}_*_\V{momentum};}}
\L{\LB{}\Tab{6}{\V{l}.\V{weight}_+=_\V{rate}_*_\V{l}.\V{dw};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_Reset_accumulated_weight_changes_to_zero\CE{}}}
\index{resetDeltas}\Proc{resetDeltas}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{resetDeltas}()_\{}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{olyr}.\V{length};_\V{i}++)}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{olyr}[\V{i}].\V{inputs}.\V{length};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{olyr}[\V{i}].\V{inputs}[\V{j}].\V{wacc}_=_\N{0};}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{hlyr}.\V{length};_\V{i}++)}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{hlyr}[\V{i}].\V{inputs}.\V{length};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{hlyr}[\V{i}].\V{inputs}[\V{j}].\V{wacc}_=_\N{0};}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_calculate_changes_in_input_weights_\&_add_them_to_the}}
\L{\LB{}\Tab{5}{wacc_(weight-accumulator)_fields._*/\CE{}}}
\index{calcInputWeights}\Proc{calcInputWeights}\L{\LB{}\Tab{2}{\K{private}_\K{void}_\V{calcInputWeights}(\V{Neuron}[\,]_\V{ns})_\{}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{ns}.\V{length};_\V{i}++)}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{ns}[\V{i}].\V{inputs}.\V{length};_\V{j}++)_\{}}
\L{\LB{}\Tab{8}{\V{Link}_\V{ln}_=_\V{ns}[\V{i}].\V{inputs}[\V{j}];}}
\L{\LB{}\Tab{8}{\V{ln}.\V{wacc}_+=_\V{ln}.\V{output}.\V{delta}()_*_\V{ln}.\V{input}.\V{act}();}}
\L{\LB{}\Tab{6}{\}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_overwrite_the_cached_activations_of_the_context_nodes_with\CE{}}}
\L{\LB{}\Tab{2}{\C{}//_the_given_value._Handy_for_starting_new_training_patterns\CE{}}}
\index{flushContext}\Proc{flushContext}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{flushContext}(\K{float}_\V{x})}}
\L{\LB{}\Tab{2}{\{_\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{clyr}.\V{length};_\V{i}++)_\V{clyr}[\V{i}].\V{act}_=_\V{x};_\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_return_sum_of_squared_errors_computed_during_backprop\CE{}}}
\index{sumSqError}\Proc{sumSqError}\L{\LB{}\Tab{2}{\K{public}_\K{float}_\V{sumSqError}()_\{_\K{return}_\V{sumSqError};_\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_read_weights_in_from_a_file_(does_not_check_for_bad_input)\CE{}}}
\index{loadWeights}\Proc{loadWeights}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{loadWeights}(\V{File}_\V{f})_\{}}
\L{\LB{}\Tab{4}{\K{try}_\{}}
\L{\LB{}\Tab{6}{\V{StreamTokenizer}_\V{input}_=_\K{new}_\V{StreamTokenizer}}}
\L{\LB{}\Tab{8}{(\K{new}_\V{BufferedReader}_(\K{new}_\V{InputStreamReader}}}
\L{\LB{}\Tab{10}{(\K{new}_\V{FileInputStream}(\V{f}))));}}
\L{\LB{}}
\L{\LB{}\Tab{6}{\V{LinkEnum}_\V{enum}_=_\K{new}_\V{LinkEnum}();}}
\L{\LB{}\Tab{6}{\K{while}_(\V{enum}.\V{hasMoreElements}())_\{}}
\L{\LB{}\Tab{8}{\K{while}_(\V{input}.\V{nextToken}()_!=_\V{input}.\V{TT\_NUMBER});}}
\L{\LB{}\Tab{8}{((\V{Link})_\V{enum}.\V{nextElement}()).\V{weight}_=_(\K{float})_\V{input}.\V{nval};}}
\L{\LB{}\Tab{6}{\}}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{\K{catch}_(\V{IOException}_\V{e})_\{_\K{throw}_\K{new}_\V{Error}(\V{e}.\V{getMessage}());_\}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_Return_number_of_trainable_weights_in_the_network._Handy}}
\L{\LB{}\Tab{5}{if_creating_an_array_for_getAllWeights()._*/\CE{}}}
\index{numWeights}\Proc{numWeights}\L{\LB{}\Tab{2}{\K{public}_\K{int}_\V{numWeights}()_\{}}
\L{\LB{}\Tab{4}{\K{return}_(\V{ilyr}.\V{length}+\V{clyr}.\V{length})*\V{hlyr}.\V{length}_\C{}//_-\!\>hidden\CE{}}}
\L{\LB{}\Tab{6}{+}\Tab{11}{(\N{1}_+_\V{hlyr}.\V{length})_*_\V{olyr}.\V{length}_;}\Tab{49}{\C{}//_-\!\>output\CE{}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_Output_all_weights_as_a_single_array_of_floats}}
\L{\LB{}\Tab{5}{order:_hidden,_output_(input_wts_of_each)_*/\CE{}}}
\index{getAllWeights}\Proc{getAllWeights}\L{\LB{}\Tab{2}{\K{public}_\K{float}[\,]_\V{getAllWeights}()_\{}}
\L{\LB{}\Tab{4}{\K{float}[\,]_\V{w}_=_\K{new}_\K{float}[\V{numWeights}()];}}
\L{\LB{}\Tab{4}{\K{int}_\V{i}=\N{0};}}
\L{\LB{}\Tab{4}{\V{LinkEnum}_\V{e}_=_\K{new}_\V{LinkEnum}();}}
\L{\LB{}\Tab{4}{\K{while}_(\V{e}.\V{hasMoreElements}())}}
\L{\LB{}\Tab{6}{\V{w}[\V{i}++]_=_((\V{Link})_\V{e}.\V{nextElement}()).\V{weight};}}
\L{\LB{}\Tab{4}{\K{return}_\V{w};}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_Set_all_weights_from_the_supplied_array_of_floats.}}
\L{\LB{}\Tab{5}{Order_same_as_getAllWeights()._*/\CE{}}}
\index{setAllWeights}\Proc{setAllWeights}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{setAllWeights}(\K{float}_\V{w}[\,])_\{}}
\L{\LB{}\Tab{4}{\K{if}_(\V{w}.\V{length}_!=_\V{numWeights}())}}
\L{\LB{}\Tab{6}{\K{throw}_\K{new}_\V{Error}(\S{}\3Wrong_number_of_weights.\3\SE{});}}
\L{\LB{}\Tab{4}{\K{int}_\V{i}=\N{0};}}
\L{\LB{}\Tab{4}{\V{LinkEnum}_\V{e}_=_\K{new}_\V{LinkEnum}();}}
\L{\LB{}\Tab{4}{\K{while}_(\V{e}.\V{hasMoreElements}())}}
\L{\LB{}\Tab{6}{((\V{Link})_\V{e}.\V{nextElement}()).\V{weight}_=_\V{w}[\V{i}++];}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}/*_Enumerate_over_all_(trainable)_links_in_network._It_can}}
\L{\LB{}\Tab{5}{be_relied_upon_always_to_enumerate_in_the_same_order._*/\CE{}}}
\L{\LB{}\Tab{2}{\K{public}_\K{class}_\V{LinkEnum}_\K{implements}_\V{Enumeration}_\{}}
\L{\LB{}\Tab{4}{\K{private}_\V{Neuron}[\,]_\V{layer};}}
\L{\LB{}\Tab{4}{\K{private}_\K{int}_\V{i},\V{j};}}
\L{\LB{}\Tab{4}{\K{private}_\V{Link}_\V{next};}}
\L{\LB{}\Tab{4}{\K{private}_\K{boolean}_\V{nextIsValid};}}
\L{\LB{}\Tab{4}{\K{private}_\K{boolean}_\V{backwards};}\Tab{32}{\C{}//_i.e._output_then_hidden\CE{}}}
\L{\LB{}}
\index{LinkEnum}\Proc{LinkEnum}\L{\LB{}\Tab{4}{\K{public}_\V{LinkEnum}()_\{_\K{this}(\K{false});_\}}}
\L{\LB{}}
\index{LinkEnum}\Proc{LinkEnum}\L{\LB{}\Tab{4}{\K{public}_\V{LinkEnum}(\K{boolean}_\V{backwards})_\{}}
\L{\LB{}\Tab{6}{\K{this}.\V{backwards}_=_\V{backwards};}}
\L{\LB{}\Tab{6}{\V{layer}_=_\V{backwards}_?_\V{olyr}_\V{:}_\V{hlyr};}}
\L{\LB{}\Tab{6}{\V{i}_=_\V{j}_=_\N{0};}}
\L{\LB{}\Tab{6}{\V{nextIsValid}_=_\K{true};}}
\L{\LB{}\Tab{6}{\V{cacheNext}();}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}}
\index{cacheNext}\Proc{cacheNext}\L{\LB{}\Tab{4}{\K{private}_\K{void}_\V{cacheNext}()_\{}}
\L{\LB{}\Tab{6}{\K{if}_(!\V{nextIsValid})_\K{throw}_\K{new}_\V{Error}}}
\L{\LB{}\Tab{8}{(\S{}\3LinkEnum_fell_off_the_end._This_really_shouldn{'}t_happen.\3\SE{});}}
\L{\LB{}\Tab{6}{\K{if}_(\V{j}\>=\V{layer}[\V{i}].\V{inputs}.\V{length})_\{\V{j}=\N{0};_\V{i}++;\}}}
\L{\LB{}\Tab{6}{\K{if}_(\V{i}\>=\V{layer}.\V{length})_\{}}
\L{\LB{}\Tab{8}{\V{i}_=_\N{0};}}
\L{\LB{}\Tab{8}{\K{if}_(\V{backwards})_\V{layer}_=_(\V{layer}==\V{olyr})_?_\V{hlyr}_\V{:}_\K{null};}}
\L{\LB{}\Tab{8}{\K{else}}\Tab{23}{\V{layer}_=_(\V{layer}==\V{hlyr})_?_\V{olyr}_\V{:}_\K{null};}}
\L{\LB{}\Tab{6}{\}}}
\L{\LB{}\Tab{6}{\K{if}_(\V{layer}==\K{null})}}
\L{\LB{}\Tab{8}{\V{nextIsValid}_=_\K{false};}}
\L{\LB{}\Tab{6}{\K{else}_\{}}
\L{\LB{}\Tab{8}{\V{next}_=_\V{layer}[\V{i}].\V{inputs}[\V{j}];}}
\L{\LB{}\Tab{8}{\V{nextIsValid}_=_\K{true};}}
\L{\LB{}\Tab{6}{\}}}
\L{\LB{}\Tab{6}{\V{j}++;}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}}
\index{hasMoreElements}\Proc{hasMoreElements}\L{\LB{}\Tab{4}{\K{public}_\K{boolean}_\V{hasMoreElements}()_\{_\K{return}_\V{nextIsValid};_\}}}
\index{nextElement}\Proc{nextElement}\L{\LB{}\Tab{4}{\K{public}_\V{Object}_\V{nextElement}()_\{}}
\L{\LB{}\Tab{6}{\K{if}_(!\V{nextIsValid})_\K{throw}_\K{new}_\V{Error}}}
\L{\LB{}\Tab{8}{(\S{}\3nextElement()_called_on_empty_link_enumerator.\3\SE{});}}
\L{\LB{}\Tab{6}{\V{Link}_\V{r}_=_\V{next};}}
\L{\LB{}\Tab{6}{\V{cacheNext}();}}
\L{\LB{}\Tab{6}{\K{return}_\V{r};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_=============_Debugging_routines_below_here\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_Dump_a_line_describing_weights_to_given_o/p_stream\CE{}}}
\L{\LB{}\Tab{2}{\C{}//_(same_order_as_dumpWeights,_naturellement)\CE{}}}
\index{describeWeights}\Proc{describeWeights}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{describeWeights}(\V{java}.\V{io}.\V{PrintStream}_\V{out})_\{}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{hlyr}.\V{length};_\V{i}++)}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{hlyr}[\V{i}].\V{inputs}.\V{length};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{out}.\V{print}(\V{hlyr}[\V{i}].\V{inputs}[\V{j}].\V{input}.\V{label}()+\V{hlyr}[\V{i}].\V{label}()+\S{}\3_\3\SE{});}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{olyr}.\V{length};_\V{i}++)}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{olyr}[\V{i}].\V{inputs}.\V{length};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{out}.\V{print}(\V{olyr}[\V{i}].\V{inputs}[\V{j}].\V{input}.\V{label}()+\V{olyr}[\V{i}].\V{label}()+\S{}\3_\3\SE{});}}
\L{\LB{}\Tab{4}{\V{out}.\V{println}();}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_Dump_the_weightings_to_the_given_output_stream\CE{}}}
\index{dumpWeights}\Proc{dumpWeights}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{dumpWeights}(\V{java}.\V{io}.\V{PrintStream}_\V{out})_\{}}
\L{\LB{}\Tab{4}{\V{dumpWeights}(\V{out},_\V{hlyr});}}
\L{\LB{}\Tab{4}{\V{dumpWeights}(\V{out},_\V{olyr});}}
\L{\LB{}\Tab{4}{\V{out}.\V{println}();}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\index{dumpWeights}\Proc{dumpWeights}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{dumpWeights}(\V{java}.\V{io}.\V{PrintStream}_\V{out},}}
\L{\LB{}\Tab{26}{\V{Neuron}[\,]_\V{nodes})_\{}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{nodes}.\V{length};_\V{i}++)}}
\L{\LB{}\Tab{6}{\K{for}_(\K{int}_\V{j}=\N{0};_\V{j}\<\V{nodes}[\V{i}].\V{inputs}.\V{length};_\V{j}++)}}
\L{\LB{}\Tab{8}{\V{out}.\V{print}(\V{nodes}[\V{i}].\V{inputs}[\V{j}].\V{weight}+\S{}\3_\3\SE{});}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}}
\L{\LB{}\Tab{2}{\C{}//_Dump_the_activations_to_the_given_output_stream\CE{}}}
\index{dumpActs}\Proc{dumpActs}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{dumpActs}(\V{java}.\V{io}.\V{PrintStream}_\V{out})_\{}}
\L{\LB{}\Tab{4}{\V{dumpActs}(\V{out},_\V{olyr},_\S{}\3Outputs:_\3\SE{});}}
\L{\LB{}\Tab{4}{\V{dumpActs}(\V{out},_\V{hlyr},_\S{}\3Hiddens:_\3\SE{});}}
\L{\LB{}\Tab{4}{\V{dumpActs}(\V{out},_\V{clyr},_\S{}\3Context:_\3\SE{});}}
\L{\LB{}\Tab{4}{\V{dumpActs}(\V{out},_\V{ilyr},_\S{}\3Inputs_:_\3\SE{});}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\index{dumpActs}\Proc{dumpActs}\L{\LB{}\Tab{2}{\K{public}_\K{void}_\V{dumpActs}(\V{java}.\V{io}.\V{PrintStream}_\V{out},_\V{Axon}[\,]_\V{ns},}}
\L{\LB{}\Tab{23}{\V{String}_\V{label})_\{}}
\L{\LB{}\Tab{4}{\V{out}.\V{print}(\V{label});}}
\L{\LB{}\Tab{4}{\K{for}_(\K{int}_\V{i}=\N{0};_\V{i}\<\V{ns}.\V{length};_\V{i}++)_\V{out}.\V{print}(\V{ns}[\V{i}].\V{act}()+\S{}\3_\3\SE{});}}
\L{\LB{}\Tab{4}{\V{out}.\V{println}();}}
\L{\LB{}\Tab{2}{\}}}
\L{\LB{}}
\L{\LB{}}
\L{\LB{\}}}
